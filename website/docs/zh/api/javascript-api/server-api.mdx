# Server API

Rsbuild 提供了面向 dev server 和 preview server 的 server API，可通过插件 hooks 和 JavaScript API 访问。

## 如何使用

### 插件 hooks

插件作者可通过 [onBeforeStartDevServer](/plugins/dev/hooks#onbeforestartdevserver) 和 [onBeforeStartPreviewServer](/plugins/dev/hooks#onbeforestartpreviewserver) 钩子访问 dev server 和 preview server 实例。

```ts
const myPlugin = () => ({
  setup(api) {
    api.onBeforeStartDevServer(({ server }) => {
      console.log('the server is ', server);
    });
    api.onBeforeStartPreviewServer(({ server }) => {
      console.log('the server is ', server);
    });
  },
});
```

### JavaScript API

- 通过 [rsbuild.createDevServer](/api/javascript-api/instance#rsbuildcreatedevserver) 创建 dev server 实例：

```ts
const server = await rsbuild.createDevServer();
console.log('the dev server is ', server);
```

- 通过 [rsbuild.startDevServer](/api/javascript-api/instance#rsbuildstartdevserver) 获取 dev server 实例：

```ts
const { server } = await rsbuild.startDevServer();
console.log('the dev server is ', server);
```

通过 [rsbuild.preview](/api/javascript-api/instance#rsbuildpreview) 获取 preview server 实例：

```ts
const { server } = await rsbuild.preview();
console.log('the preview server is ', server);
```

## 示例

### 与自定义 server 集成

下面是一个在 [express](https://expressjs.com/) 中集成 Rsbuild dev server 的例子:

```ts
import { createRsbuild } from '@rsbuild/core';
import express from 'express';

async function startDevServer() {
  // 初始化 Rsbuild
  const rsbuild = await createRsbuild({
    config: {
      server: {
        middlewareMode: true,
      },
    },
  });
  const app = express();

  // 创建 Rsbuild dev server 实例
  const rsbuildServer = await rsbuild.createDevServer();

  // 使用 Rsbuild 的内置中间件
  app.use(rsbuildServer.middlewares);

  const server = app.listen(rsbuildServer.port, async () => {
    // 通知 Rsbuild 自定义 Server 已启动
    await rsbuildServer.afterListen();
  });

  // 激活 WebSocket 连接
  rsbuildServer.connectWebSocket({ server });
}
```

更多用法可参考：

- [示例代码](https://github.com/rstackjs/rstack-examples/blob/main/rsbuild/express/server.mjs)。
- [rsbuild.createDevServer](/api/javascript-api/instance#rsbuildcreatedevserver)
- [server.middlewareMode](/config/server/middleware-mode)

## 类型定义

### 共享 API

在 dev server 和 preview server 中都可用的公共方法和属性。

```ts
type RsbuildServerBase = {
  /**
   * 关闭 server
   * 在 dev server 中会触发 `onCloseDevServer` 钩子
   */
  close: () => Promise<void>;
  /**
   * Node.js HTTP 服务器实例
   * - 如果使用了 `server.https` 配置，则为 `Http2SecureServer`
   * - 如果开启了 `server.middlewareMode` 配置，则为 `null`
   */
  httpServer:
    | import('node:http').Server
    | import('node:http2').Http2SecureServer
    | null;
  /**
   * `connect` 实例
   * 可用于向 server 附加自定义中间件
   */
  middlewares: Connect.Server;
  /**
   * 解析后的端口号
   * 默认情况下，Rsbuild server 会监听 `3000` 端口，如果端口被占用，则自动递增端口号
   */
  port: number;
};
```

### Dev server API

仅在 dev server 中可用的方法和属性。

```ts
type RsbuildDevServer = RsbuildServerBase & {
  /**
   * 通知 Rsbuild 自定义 Server 已启动
   * Rsbuild 会在此阶段触发 `onAfterStartDevServer` 钩子
   */
  afterListen: () => Promise<void>;
  /**
   * 激活 WebSocket 连接
   * 这确保了 HMR 正常工作
   */
  connectWebSocket: (options: {
    server: import('node:http').Server | import('node:http2').Http2SecureServer;
  }) => void;
  /**
   * Rsbuild server 提供的 environment API
   */
  environments: EnvironmentAPI;
  /**
   * 监听 Rsbuild dev server
   * 当你使用自定义 server 时，不需要调用该方法
   */
  listen: () => Promise<{
    port: number;
    urls: string[];
    server: RsbuildDevServer;
  }>;
  /**
   * 启动服务器后，在浏览器中打开 URL
   */
  open: () => Promise<void>;
  /**
   * 打印 server URLs
   */
  printUrls: () => void;
  /**
   * 允许中间件向 HMR 客户端发送一些消息，HMR 客户端将根据接收到的消息类型进行不同的处理。
   * - `static-changed`: 页面将会重新加载。
   */
  sockWrite: SockWrite;
};
```

## API

### afterListen

- **类型:** `() => Promise<void>`
- **适用范围:** Dev 专有

通知 Rsbuild 自定义的开发服务器已成功启动，Rsbuild 将在这个阶段触发 [onAfterStartDevServer](/plugins/dev/hooks#onafterstartdevserver) 钩子。

例如：

```ts
import express from 'express';
import { createRsbuild } from '@rsbuild/core';

const rsbuild = await createRsbuild();
const rsbuildServer = await rsbuild.createDevServer();
const app = express();

const server = app.listen(rsbuildServer.port, async () => {
  await rsbuildServer.afterListen();
});
```

### close

- **类型:** `() => Promise<void>`
- **适用范围:** 通用

调用 `close()` 方法来执行必要的清理操作。

在 dev server 中，这还会触发 [onCloseDevServer](/plugins/dev/hooks#onclosedevserver) 钩子。

```ts
import { createRsbuild } from '@rsbuild/core';

const rsbuild = await createRsbuild();
const rsbuildServer = await rsbuild.createDevServer();

await rsbuildServer.close();
```

### connectWebSocket

- **类型:**
- **适用范围:** Dev 专有

```ts
type ConnectWebSocket = (options: {
  server: import('node:http').Server | import('node:http2').Http2SecureServer;
}) => void;
```

激活 WebSocket 连接，这确保了 HMR 正常工作。

Rsbuild 内置了 WebSocket 处理器以支持 HMR 功能：

1. 当用户通过浏览器访问页面时，会自动向服务器发起 WebSocket 连接请求。
2. Rsbuild 开发服务器检测到连接请求后，会指示内置的 WebSocket 处理器进行处理。
3. 浏览器与 Rsbuild WebSocket 处理器成功建立连接后，便可进行实时通信。
4. 每次重新编译完成后，Rsbuild WebSocket 处理器会通知浏览器。随后，浏览器向开发服务器发送 `hot-update.(js|json)` 请求，以加载编译后的新模块。

当你使用自定义 server 时，可能会遇到 HMR 连接失败的问题。这是因为自定义 server 未能将 WebSocket 连接请求正确转发至 Rsbuild 的 WebSocket 处理器。此时，你需要调用 `connectWebSocket` 方法来让 Rsbuild 能够接收并处理来自浏览器的 WebSocket 连接请求。

```ts
import express from 'express';
import { createRsbuild } from '@rsbuild/core';

const rsbuild = await createRsbuild();
const rsbuildServer = await rsbuild.createDevServer();
const app = express();

const httpServer = app.listen(rsbuildServer.port);

rsbuildServer.connectWebSocket({ server: httpServer });
```

### environments

- **Type:** [EnvironmentAPI](/api/javascript-api/environment-api#environment-api)
- **适用范围:** Dev 专有

提供 Rsbuild 的 [environment API](/api/javascript-api/environment-api#environment-api)，这允许你在服务端获取特定环境下的构建产物信息。

```ts title="rsbuild.config.ts"
const rsbuildServer = await rsbuild.createDevServer();
const webStats = await rsbuildServer.environments.web.getStats();

console.log(webStats.toJson({ all: false }));
```

### middlewares

- **类型：** `Connect.Server`
- **适用范围:** 通用

`connect` 实例，可用于向服务器附加自定义中间件。

> 查看 [中间件](/guide/basic/server#middleware) 了解更多。

### sockWrite

- **类型:**
- **适用范围:** Dev 专有

```ts
type SockWrite = {
  (type: 'static-changed'): void;
  (type: 'custom', data?: { event: string; data?: any }): void;
};
```

向 HMR 客户端传递一些消息，HMR 客户端将根据接收到的消息类型进行不同的处理。

#### static-changed

如果你发送一个 `'static-changed'` 的消息，页面将会重新加载。

```ts
const rsbuildServer = await rsbuild.createDevServer();
if (someCondition) {
  rsbuildServer.sockWrite('static-changed');
}
```

#### custom

你也可以通过 `custom` 类型向浏览器发送自定义消息，并携带可选的 data，然后通过 HMR 事件进行处理：

```ts title="server.js"
const rsbuildServer = await rsbuild.createDevServer();
rsbuildServer.sockWrite('custom', { event: 'count', data: { value: 1 } });
```

Rsbuild 在 Rspack 的 [import.meta.webpackHot](https://rspack.rs/api/runtime-api/hmr) 对象上扩展了 `on()` 方法，它允许你在浏览器端监听自定义事件，并处理数据：

```ts title="client.js"
if (import.meta.webpackHot) {
  import.meta.webpackHot.on('count', (data) => {
    console.log('count update', data.value);
  });
  import.meta.webpackHot.accept();
}
```
