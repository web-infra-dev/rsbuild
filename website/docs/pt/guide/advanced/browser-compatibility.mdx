# Compatibilidade do navegador

O Rsbuild suporta [navegadores modernos](/guide/advanced/browserslist#default-browserslist) por padrão e oferece recursos de downgrade de sintaxe e API para garantir a compatibilidade com navegadores legados que suportam ES5 (como o IE11).

Este capítulo apresenta como usar os recursos fornecidos pelo Rsbuild para lidar com problemas de compatibilidade do navegador.

## Definir browserslist

Antes de lidar com problemas de compatibilidade, você precisa primeiro esclarecer quais navegadores seu projeto precisa suportar e adicionar a configuração de browserslist correspondente.

- Se você ainda não definiu o browserslist, leia primeiro o capítulo [Browserslist](/guide/advanced/browserslist).

- Se você definiu um browserslist, o Rsbuild compilará automaticamente de acordo com esse escopo, fará o downgrade da sintaxe JavaScript e CSS e injetará o polyfill necessário. Na maioria dos casos, você pode usar com segurança os recursos modernos do ECMAScript sem se preocupar com problemas de compatibilidade.

Após definir o browserslist, se você ainda encontrar alguns problemas de compatibilidade, continue lendo o conteúdo abaixo para encontrar algumas soluções.

:::tip O que é polyfill
Um polyfill é um pedaço de código que fornece a funcionalidade de um recurso mais recente para navegadores mais antigos que não suportam esse recurso nativamente. Ele é usado para preencher as lacunas nas implementações de padrões da web de navegadores mais antigos, permitindo que os desenvolvedores usem recursos mais recentes com segurança, sem ter que se preocupar se eles funcionarão ou não em navegadores mais antigos. Por exemplo, se um navegador não suporta o Array.map() method, um polyfill can be used to provide that functionality, allowing code that uses `Array.prototype.flat()` to work in that browser. Polyfills are commonly used to ensure that web applications can work on a wide range of browsers, including older ones.
:::

## Conhecimento básico

Before dealing with compatibility issues, it is recommended that you understand the following background knowledge to better handle related issues.

### Downgrade de sintaxe e downgrade de API

Quando você usa sintaxe e API de versão superior em seu projeto, para fazer com que o código compilado seja executado de forma estável em navegadores de versão inferior, precisamos fazer o downgrade de duas partes: downgrade de sintaxe e downgrade de API.

**O Rsbuild faz o downgrade da sintaxe através da transpilação de sintaxe e o downgrade da API através da injeção de polyfill.**

> Gramática e API não estão fortemente ligadas. Quando os fabricantes de navegadores implementam o motor, eles suportarão algumas sintaxes ou implementarão algumas APIs antecipadamente de acordo com a especificação ou suas próprias necessidades. Portanto, navegadores de diferentes fabricantes no mesmo período não são necessariamente compatíveis com sintaxe e API. Assim, na prática geral, sintaxe e API são tratadas em duas partes.

### Transpilação de sintaxe

**Sintaxe é uma série de regras sobre como uma linguagem de programação organiza o código**, e o código que não segue essas regras não pode ser reconhecido corretamente pelo motor da linguagem de programação e, portanto, não pode ser executado. Em JavaScript, os exemplos a seguir são regras de sintaxe:

- Em `const foo = 1`, `const` means to declare an immutable constant.
- Em `foo?.bar?.baz`, `?.` indicates optional chaining of access properties.
- Em `async function () {}`, `async` means to declare an asynchronous function.

Because the parsers of different browsers can support different syntax, especially the old version of the browser engine can support less grammar, so when some syntax are run in the lower version of the browser engine, an error will be reported at the stage of parsing the AST .

For example, the following code will report an error in IE browser or a lower version of Node.js:

```js
const foo = {};
foo?.bar();
```

When we run this code in a low version of Node.js, the following error message will appear:

```bash
SyntaxError: Unexpected token.
   at Object.exports.runInThisContext (vm.js:73:16)
   at Object.<anonymous> ([eval]-wrapper:6:22)
   at Module._compile (module.js:460:26)
   at evalScript (node.js:431:25)
   at startup (node.js:90:7)
   at node.js:814:3
```

It is obvious from the error message that this is a syntax error. This means that this syntax is not supported in lower versions of the engine.

**Syntax can not be supported by polyfill or shim**. If you want to run some syntax that it does not originally support in a low-version browser, you need to transpile the code into a syntax that the low-version engine can support.

Transpile the above code into the following code to run in lower version engines:

```js
var foo = {};
foo === null || foo === void 0 ? void 0 : foo.bar();
```

After transpilation, the syntax of the code has changed, and some syntax that the engine of the lower version cannot understand has been replaced with the syntax it can understand, **but the meaning of the code itself has not changed**.

If the engine encounters an unrecognized syntax when converting to AST, it will report a syntax error and abort the code execution process. In this case, if your project does not use capabilities such as SSR or SSG, the page will be blank, making the page unavailable.

If the code is successfully converted to AST, the engine will convert the AST into executable code and execute it normally inside the engine.

### Polyfill de API

JavaScript is an interpreted scripting language, unlike compiled languages like Rust. Rust will check the calls in the code during the compilation phase, and JavaScript does not know whether the function called by this line of code exists before it actually runs to a certain line of code, so some errors will only appear at runtime.

For example:

```js
var str = 'Hello world!';
console.log(str.notExistedMethod());
```

The above code has correct syntax and can be converted to AST correctly in the first stage of the engine runtime, but when it is actually running, because the method `notExistedMethod` does not exist on `String.prototype`, an error will be reported:

```bash
Uncaught TypeError: str.notExistedMethod is not a function
   at <anonymous>:2:17
```

With the iteration of ECMAScript, some new methods will be added to be built-in objects. For example, `String.prototype.replaceAll` was introduced in ES2021, then the `replaceAll` method does not exist in the built-in object `String.prototype` of most browser engines before 2021, so the following code works in the latest Chrome, but not in earlier versions:

```js
'abc'.replaceAll('abc', 'xyz');
```

In order to solve the problem that `String.prototype` lacks `replaceAll` in older browsers, we can extend the `String.prototype` object in older browsers and add the `replaceAll` method to it, for example:

```js
// The implementation of this polyfill does not necessarily conform to the standard, it is only used as an example.
if (!String.prototype.replaceAll) {
  String.prototype.replaceAll = function (str, newStr) {
    // If a regex pattern
    if (
      Object.prototype.toString.call(str).toLowerCase() === '[object regexp]'
    ) {
      return this.replace(str, newStr);
    }
    // If a string
    return this.replace(new RegExp(str, 'g'), newStr);
  };
}
```

> This technique of providing implementations for legacy environments to align new APIs is called polyfill.

## Escopo de compilação

Por padrão, o Rsbuild usa [SWC](/guide/configuration/swc) para compilar todos os módulos JavaScript e TypeScript, mas exclui módulos JavaScript no diretório `node_modules`.

Essa abordagem é projetada para evitar impactar o desempenho da build ao fazer o downgrade de todas as dependências de terceiros, ao mesmo tempo em que evita possíveis problemas decorrentes do downgrade redundante de dependências de terceiros pré-compiladas.

### Código-fonte

O código-fonte do projeto atual será rebaixado por padrão, então você não precisa adicionar configuração adicional, apenas certifique-se de que a configuração do browserslist esteja definida corretamente.

### Dependências de terceiros

Quando você descobrir que uma dependência de terceiros causa problemas de compatibilidade, você pode adicionar essa dependência à configuração [source.include](/config/source/include) do Rsbuild, fazendo com que o Rsbuild faça uma compilação extra para essa dependência.

Tomando o pacote npm `query-string` as an example, you can add the following config:

```ts title="rsbuild.config.ts"
import path from 'node:path';

export default {
  source: {
    include: [/node_modules[\\/]query-string[\\/]/],
  },
};
```

Consulte [source.include](/config/source/include) para uso detalhado.

## Modo Polyfill

O Rsbuild compila código JavaScript usando SWC e suporta a injeção de polyfills como [core-js](https://github.com/zloirock/core-js) e [@swc/helpers](https://npmjs.com/package/@swc/helpers).

Em diferentes cenários de uso, você pode precisar de diferentes soluções de polyfill. O Rsbuild fornece a configuração [output.polyfill](/config/output/polyfill) para alternar entre diferentes modos de polyfill.

### Comportamento padrão

O Rsbuild não injeta nenhum polyfill por padrão:

```ts
export default {
  output: {
    polyfill: 'off',
  },
};
```

### Modo de uso

Quando você habilita o modo de uso, o Rsbuild analisará o código-fonte no projeto e determinará quais polyfills precisam ser injetados.

Por exemplo, o código usa o objeto `Map`:

```js
var b = new Map();
```

Após a compilação, apenas os polyfills para `Map` serão injetados neste arquivo:

```js
import 'core-js/modules/es.map';
var b = new Map();
```

A vantagem deste método é que o tamanho do polyfill injetado é menor, o que é adequado para projetos com maiores requisitos de tamanho de bundle. A desvantagem é que polyfill pode not be fully injected, because third-party dependencies will not be compiled and downgraded by default, so the polyfill required by third-party dependencies will not be analyzed. If you need to analyze a third-party dependency, you also need to add it to [source.include](/config/source/include) config.

The config of usage mode is:

```ts
export default {
  output: {
    polyfill: 'usage',
  },
};
```

### Modo de entrada

When using the entry mode, Rsbuild will analyze which `core-js` methods need to be injected according to the browserslist set by the current project, and inject them to the entry file of each page. The polyfill injected in this way is more comprehensive, and there is no need to worry about the project source code and third-party dependencies polyfill issues. However, because some unused polyfill codes are included, the bundle size may increase.

The config of entry mode is:

```ts
export default {
  output: {
    polyfill: 'entry',
  },
};
```

### Polyfill de UA

Cloudflare provides a [polyfill service](https://cdnjs.cloudflare.com/polyfill/) that can automatically generate polyfill bundle based on the user's browser User-Agent.

You can use the [html.tags](/config/html/tags) config of Rsbuild to inject scripts. For example, injecting a `<script>` tag at the beginning of the `<head>` tag:

```ts
export default {
  html: {
    tags: [
      {
        tag: 'script',
        attrs: {
          defer: true,
          src: 'https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=default',
        },
        append: false,
      },
    ],
  },
};
```
