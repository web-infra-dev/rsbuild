# Divisão de Código (Code Splitting)

Uma ótima estratégia de divisão de chunks é muito importante para melhorar o desempenho de carregamento da aplicação. Ela pode fazer uso total do mecanismo de cache do navegador para reduzir o número de requisições e melhorar a velocidade de carregamento da aplicação.

Várias [estratégias de divisão de chunks](/guide/optimization/code-splitting) são incorporadas ao Rsbuild. Elas devem atender às necessidades da maioria das aplicações. Você também pode personalizar a configuração de divisão de chunks para se adequar ao seu próprio cenário de uso.

> Consulte [Rspack - Code Splitting](https://rspack.rs/guide/optimization/code-splitting) para mais detalhes.

## Estratégias

> A configuração de divisão de chunks do Rsbuild é em [performance.chunkSplit](/config/performance/chunk-split).

O Rsbuild suporta as seguintes estratégias de divisão de chunks:

- `split-by-experience`: uma estratégia de divisão empírica, divide automaticamente alguns pacotes npm comumente usados em chunks de tamanho moderado.
- `split-by-module`: divide por granularidade de pacote NPM, cada pacote NPM corresponde a um chunk.
- `split-by-size`: divide automaticamente de acordo com o tamanho do módulo.
- `all-in-one`: agrupa todo o código em um único chunk.
- `single-vendor`: agrupa todos os pacotes NPM em um único chunk.
- `custom`: estratégia de divisão de chunks personalizada.

## split-by-experience

### Comportamento

O Rsbuild adota a estratégia `split-by-experience` por padrão, que é uma estratégia que desenvolvemos a partir da experiência. Especificamente, quando os seguintes pacotes npm são referenciados em seu projeto, eles serão automaticamente divididos em chunks separados:

- `lib-polyfill.js`: inclui `core-js`, `@swc/helpers`, `tslib`.
- `lib-axios.js`: inclui `axios` e pacotes relacionados.

Agrupar pacotes comumente usados dessa forma e depois dividi-los em chunks individuais ajuda no cache do navegador.

### Configuração

```ts
export default {
  performance: {
    chunkSplit: {
      strategy: 'split-by-experience',
    },
  },
};
```

### Observações

- Se os pacotes npm mencionados acima não estiverem instalados ou usados no projeto, o chunk correspondente não será gerado.

## split-by-module

### Comportamento

Divide cada pacote NPM em um Chunk.

::: warning
Esta estratégia dividirá o `node_modules` da maneira mais granular e, ao mesmo tempo, sob HTTP/2, a multiplexação acelerará o tempo de carregamento dos recursos. No entanto, em ambientes não-HTTP/2, ela precisa ser usada com cautela devido ao problema de bloqueio de cabeçalho de linha HTTP.
:::

### Configuração

```ts
export default {
  performance: {
    chunkSplit: {
      strategy: 'split-by-module',
    },
  },
};
```

### Observações

- Esta configuração dividirá o `node_modules` em chunks menores, resultando em um grande número de requisições de arquivo.
- Ao usar HTTP/2, o tempo de carregamento de recursos será acelerado e a taxa de acertos do cache será melhorada devido à multiplexação.
- Quando não estiver usando HTTP/2, o desempenho do carregamento da página pode ser reduzido devido ao bloqueio de cabeçalho de linha HTTP. Use com cautela.

## all-in-one

### Comportamento

Esta estratégia coloca todo o código-fonte e dependências de terceiros no mesmo Chunk.

### Configuração

```ts
export default {
  performance: {
    chunkSplit: {
      strategy: 'all-in-one',
    },
  },
};
```

### Observações

- Esta configuração agrupará todo o código JS gerado em um único arquivo (exceto para chunks importados dinamicamente).
- O tamanho de um único arquivo JS pode ser muito grande, levando a uma diminuição no desempenho de carregamento da página.

Se você precisar agrupar os chunks divididos por importação dinâmica em um único arquivo, você pode definir a opção [output.asyncChunks](https://rspack.rs/config/output#outputasyncchunks) no Rspack como `false`:

```js
export default defineConfig({
  performance: {
    chunkSplit: {
      strategy: 'all-in-one',
    },
  },
  tools: {
    rspack: {
      output: {
        asyncChunks: false,
      },
    },
  },
});
```

## single-vendor

### Comportamento

Esta estratégia coloca as dependências de terceiros em um Chunk e o código-fonte em outro chunk.

### Configuração

```ts
export default {
  performance: {
    chunkSplit: {
      strategy: 'single-vendor',
    },
  },
};
```

### Observações

- O tamanho de um único arquivo de fornecedor pode ser muito grande, levando a uma diminuição no desempenho de carregamento da página.

## split-by-size

### Comportamento

Sob esta estratégia, após definir `minSize` e `maxSize` para um valor fixo, o Rsbuild os dividirá automaticamente sem configuração extra.

### Configuração

```ts
export default {
  performance: {
    chunkSplit: {
      strategy: 'split-by-size',
      minSize: 30000,
      maxSize: 50000,
    },
  },
};
```

## Estratégia de divisão personalizada

Além de usar as estratégias embutidas, você também pode personalizar a estratégia de divisão para atender a mais necessidades de personalização. A estratégia personalizada é dividida em duas partes:

- Grupo personalizado
- Configuração `splitChunks` personalizada do Rspack

É importante notar que essas duas capacidades personalizadas podem ser usadas em conjunto com a estratégia embutida, ou seja, você pode usar a estratégia embutida para dividir pacotes comumente usados e, em seguida, usar a função personalizada para dividir outros pacotes.

### Grupo personalizado

O Rsbuild suporta grupo personalizado, que é mais flexível do que as estratégias embutidas e mais simples do que escrever a configuração `splitChunks` do Rspack.

Por exemplo, divida a biblioteca `axios` em `node_modules` em `axios.js`:

```js
export default {
  performance: {
    chunkSplit: {
      forceSplitting: {
        axios: /node_modules[\/]axios/,
      },
    },
  },
};
```

Através da configuração `forceSplitting`, você pode facilmente dividir alguns pacotes em um Chunk.

#### Observações

Chunks divididos usando a configuração `forceSplitting` serão inseridos no arquivo HTML como recursos solicitados para a tela inicial usando tags `<script>`. Portanto, divida-os apropriadamente com base no cenário real para evitar tamanho excessivo dos recursos da tela inicial.

### Configuração personalizada

Além de usar o agrupamento personalizado, você também pode personalizar a configuração `splitChunks` do Rspack através de `override`, por exemplo:

- Defina `minSize` para 30.000, o que significa que módulos menores que 30.000 bytes não serão divididos.

```ts
export default {
  performance: {
    chunkSplit: {
      override: {
        chunks: 'all',
        minSize: 30000,
      },
    },
  },
};
```

- Agrupe todos os arquivos CSS em um único `styles.css`.

```ts
export default {
  performance: {
    chunkSplit: {
      override: {
        cacheGroups: {
          styles: {
            name: 'styles',
            minSize: 0,
            chunks: 'all',
            test: /\.(?:css|less|sass|scss|styl)$/,
            priority: 99,
          },
        },
      },
    },
  },
};
```

A configuração `override` será mesclada com a configuração `splitChunks` do Rspack. Para detalhes específicos da configuração, consulte [Rspack - splitChunks](https://rspack.rs/config/optimization#optimization-splitchunks).

## Usando importação dinâmica para divisão de código

Além das configurações `chunkSplit`, usar [importação dinâmica](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import) para divisão de código também é uma técnica de otimização importante que pode efetivamente reduzir o tamanho inicial do bundle.

:::tip Sobre importação dinâmica
A importação dinâmica é um novo recurso introduzido no ECMAScript 2020 que permite carregar módulos JavaScript dinamicamente. O Rspack subjacente usado pelo Rsbuild suporta importação dinâmica por padrão, então você pode usá-lo diretamente em seu código.
:::

Quando o empacotador encontra a sintaxe `import()`, ele divide automaticamente o código relevante em um novo chunk e o carrega sob demanda em tempo de execução.

Por exemplo, se o seu projeto tiver um módulo grande chamado `bigModule.ts` (que também pode ser uma dependência de terceiros), você pode usar a importação dinâmica para carregá-lo sob demanda:

```js
// Em algum lugar do seu código onde você precisa usar bigModule
import('./bigModule.ts').then((bigModule) => {
  // Use bigModule aqui
});
```

Quando você executa o comando de build, `bigModule.ts` será automaticamente dividido em um novo chunk e carregado sob demanda em tempo de execução.
